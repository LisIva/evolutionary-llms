What is a possible function with the general equation form {full_form} that could be described with the set of points named points_set, that have the form of '{dots_order}'. Give an answer in the function equation_v1 constructing it in a way described by equation_v0.
The dictionary exp_buffer stores previous attempts to find the equation evaluated with evaluate function. While generating equation_v1 look at the exp_buffer and use the scores presented there to make a new guess about the equation structure. The best score is 0.
Note that although the general equation form is {full_form}, the resulting equation may take on simpler forms (BUT IT DOESN'T HAVE TO!), like {left_deriv} = F(t, du/dx).
Make sure the suggested equation is dependent on at least one derivative, so in the provided case du/dx must be included.

Requirements:
1. First look at the exp_buffer and then suggest the equation, the string form of which is not already there!
2. Do not copy the equations from the exp_buffer!
3. Only give a simplified version of the equation in string_form_of_the_equation: always open the brackets, for ex. instead of 'du/dt = c[0] * (1 + du/dx) * t' return 'du/dt = c[0] * t + c[1] * du/dx * t'.

import numpy as np
from scipy.optimize import minimize

def loss_function(params, t, x, u, derivs_dict):
    u_pred = equation_v1(t, x, u, derivs_dict, params)[0]
    return np.mean((u_pred-derivs_dict["{left_deriv}"])**2)

def eval_metric(params, t, x, u, derivs_dict, left_side):
    u_pred = equation_v1(t, x, u, derivs_dict, params)[0]
    return np.mean(np.fabs(u_pred - derivs_dict[left_side]))

def evaluate(data: dict) -> float:
    """ Evaluate the constructed equation"""
    inputs, derivs_dict = data['inputs'], data["derivs_dict"]
    # Optimize equation skeleton parameters
    loss_partial = lambda params: loss_function(params, *inputs, derivs_dict)
    params_initial_guess = np.array([1.0]*P)
    result = minimize(loss_partial, params_initial_guess, method='BFGS')
    optimized_params = result.x
    # Return evaluation score
    score = eval_metric(optimized_params, *inputs, derivs_dict, left_side)
    return score if not np.isnan(score) and not np.isinf(score) else None


#/Input data

points_set =
{points_set}
exp_buffer = {{
"du/dt = c[0] * t * du/dx + c[1] * u * d^3u/dx^3": 921,
"du/dt = c[0] * t * du/dx + c[1] * u * d^2u/dx^2": 920,
"du/dt = c[0] * t * du/dx + c[1]": 882,
"du/dt = c[0] * du/dx": 848,
"du/dt = c[0] * du/dx + c[1] * t * d^2u/dx^2": 843,
"du/dt = c[0] * du/dx + c[1] * t * d^2u/dx^2 + c[2] * u * d^3u/dx^3": 814,
"du/dt = c[0] * x * du/dx + c[1] * t * d^2u/dx^2 + c[2] * u * du/dx": 813,
"du/dt = c[0] * du/dx + c[1] * u": 806,
"du/dt = c[0] * np.exp(-c[1]*t) * du/dx + c[2]*u": 796,
"du/dt = c[0] * t * du/dx + c[1] * u * d^2u/dx^2 + c[2] * (du/dx)^2": 792,
"du/dt = c[0] * t * du/dx + c[1] * x * du/dx + c[2] * u * d^2u/dx^2": 779,
"du/dt = c[0] * du/dx + c[1] * d^2u/dx^2 + c[2] * x": 774,
"du/dt = c[0] * du/dx + c[1] * u + c[2] * d^2u/dx^2": 769,
"du/dt = c[0] * ( du/dx + u ) + c[1] * u * ( t + x ) + c[2] * d^2u/dx^2 * (t^2 + x^2) + c[3] * t^3 + c[4] * x^3": 765,
"du/dt = c[0] * du/dx + c[1] * t * d^3u/dx^3": 759,
"du/dt = c[0] * du/dx + c[1] * d^2u/dx^2 + c[2] * t * du/dx": 725,
"du/dt = c[0] * t * du/dx + c[1] * x * d^2u/dx^2 + c[2] * (du/dx)**2": 722,
"du/dt = c[0] * t + c[1] * x + c[2] * u + c[3] * du/dx + c[4] * d^2u/dx^2": 713,
"du/dt = c[0] * t + c[1] * du/dx + c[2] * d^3u/dx^3": 699,}}

#/end of input data

""" An example of desired output: """
def equation_v0(t: np.ndarray, x: np.ndarray, u: np.ndarray, derivs_dict: dict(), params: np.ndarray):
    right_side = params[0] * derivs_dict["du/dx"]
    string_form_of_the_equation = "{left_deriv} = c[0] * du/dx"
    len_of_params = 1
    return right_side, string_form_of_the_equation, len_of_params

""" The function to complete: """
def equation_v1(t: np.ndarray, x: np.ndarray, u: np.ndarray, derivs_dict: dict(), params: np.ndarray):
    """Generate the code"""