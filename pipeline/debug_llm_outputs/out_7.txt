The given problem involves generating an equation that best fits the data points provided, with restrictions on the form the equation can take. To generate a new equation that is not in the exp_buffer, we need to look at the structure of the best performing equations from the buffer and make a guess about a new form.

The simplest two-term equations in the exp_buffer, namely: 
1. "d^2u/dt^2 = c[0] * du/dx + c[1] * u"
   with a score of 4.12 , and 
2. "d^2u/dt^2 = c[0] * du/dx + c[1] * (du/dx)^2"
   with a score of 7.84,
provide a guide to how the best forms seem to involve a linear term for du/dx. We can hence create a new form incorporating c[0], du/dx, and an additional term du/dx * u, as a further variation from the top scoring structure.

Writing this in python function form, we get:

```python
def equation_v1(t: np.ndarray, x: np.ndarray,
                u: np.ndarray, derivs_dict: dict(),
                params: np.ndarray):
    right_side = params[0] * derivs_dict["du/dx"] + derivs_dict["du/dx"]*u
    string_form_of_the_equation = "d^2u/dt^2 = c[0] * du/dx + du/dx*u"
    len_of_params = 1
    return (right_side, string_form_of_the_equation, len_of_params)
```

Please keep in mind that this function does not check for data consistency or parameter validity, it is a response to the asked for equation creation based on given points. Moreover, this is a simplified approach that ignores full thermodynamics of general equation solving. Correct dynamic equation solving could require adding dependence on more variables, sophisticated equation solving techniques, and in-depth understanding of the data itself.